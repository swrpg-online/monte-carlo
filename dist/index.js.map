{
  "version": 3,
  "sources": ["../src/index.ts", "../node_modules/@swrpg-online/dice/src/types.ts", "../node_modules/@swrpg-online/dice/src/hints.ts", "../node_modules/@swrpg-online/dice/src/dice.ts", "../node_modules/@swrpg-online/dice/src/pools.ts", "../src/MonteCarlo.ts"],
  "sourcesContent": ["export { MonteCarlo, MonteCarloError } from \"./MonteCarlo\";\nexport type { DicePool } from \"@swrpg-online/dice\";\nexport type { DiceResult } from \"@swrpg-online/dice/dist/types\";\nexport type {\n  MonteCarloResult,\n  HistogramData,\n  DistributionAnalysis,\n} from \"./MonteCarlo\";\n", "export type DicePool = {\n  boostDice?: number;\n  abilityDice?: number;\n  proficiencyDice?: number;\n  setBackDice?: number;\n  difficultyDice?: number;\n  challengeDice?: number;\n  forceDice?: number;\n};\n\nexport type DiceResult = {\n  successes: number;\n  failures: number;\n  advantages: number;\n  threats: number;\n  triumphs: number;\n  despair: number;\n  lightSide: number;\n  darkSide: number;\n  hints?: string[];\n};\n\nexport type DieType =\n  | \"boost\"\n  | \"ability\"\n  | \"proficiency\"\n  | \"setback\"\n  | \"difficulty\"\n  | \"challenge\"\n  | \"force\";\n\nexport type DetailedDieResult = {\n  type: DieType;\n  roll: number;\n  result: DiceResult;\n};\n\nexport type RollResult = {\n  results: DetailedDieResult[];\n  summary: DiceResult;\n};\n\nexport const SYMBOLS = {\n  SUCCESS: \"SUCCESS\" as const,\n  FAILURE: \"FAILURE\" as const,\n  ADVANTAGE: \"ADVANTAGE\" as const,\n  THREAT: \"THREAT\" as const,\n  TRIUMPH: \"TRIUMPH\" as const,\n  DESPAIR: \"DESPAIR\" as const,\n  LIGHT: \"LIGHT\" as const,\n  DARK: \"DARK\" as const,\n} as const;\n\nexport type Symbol = keyof typeof SYMBOLS;\n\nexport type RollOptions = {\n  hints?: boolean;\n  /**\n   * Maximum number of dice allowed per die type.\n   * Default: 100\n   */\n  maxDicePerType?: number;\n  /**\n   * Maximum total number of dice allowed in a single roll.\n   * Default: 500\n   */\n  maxTotalDice?: number;\n  /**\n   * Whether to throw an error when dice limits are exceeded.\n   * If false, dice counts will be silently capped to the maximum.\n   * Default: false\n   */\n  throwOnLimitExceeded?: boolean;\n};\n", "import { SYMBOLS, type Symbol } from \"./types\";\n\n// 1 advantage or 1 triumph\nconst recoverOneStrain = \"Recover one strain (may be applied more than once).\";\nconst addBoostDieToActiveAlly =\n  \"Add a boost die to the next allied active character's check.\";\nconst noticeImportantPoint =\n  \"Notice a single important point in the ongoing conflict, such as the location of a blast door's control panel or a weak point on an attack speeder.\";\nconst inflictCriticalInjury =\n  \"Inflict a Critical Injury with a successful attack that deals damage past soak (Advantage cost may vary).\";\nconst activateWeaponQuality =\n  \"Activate a weapon quality (Advantage cost may vary).\";\n\n// 2 advantage or 1 triumph\nconst performManeuver =\n  \"Perform an immediate free maneuver that does not exceed the two maneuver per turn limit.\";\nconst addSetbackDie =\n  \"Add a setback die to the targeted character's next check.\";\nconst addBoostDieToAnyAlly =\n  \"Add a boost die to any allied character's next check, including that of the active character.\";\n\n// 3 advantage or 1 triumph\nconst negateEnemy =\n  \"Negate the targeted enemy's defensive bonuses (such as the defense gained from cover, equipment, or performing the Guarded Stance maneuver) util the end of the current round.\";\nconst ignoreEnvironment =\n  \"Ignore penalizing environmental effects such as inclement weather, zero gravity, or similar circumstances until the end of the active character's next turn.\";\nconst disableOpponent =\n  \"When dealing damage to a target, have the attack disable the opponent or one piece of gear rather than dealing wounds or strain. This could include hobbling them temporarily with a shot to the leg, or disabling their comlink. This should be agreed upon by the player and the GM, and the effects are up to the GM (although Table 6-10: Critical Injury Result is a god resource to consult for possible effects). The effects should be temporary and not too excessive.\";\nconst gainDefense =\n  \"Gain + 1 melee or ranged defense until the end of the active character's next turn.\";\nconst dropWeapon =\n  \"Force the target to drop a melee or ranged weapon they are wielding.\";\n\n// 1 triumph\nconst upgradeDifficultyTargetedCharacter =\n  \"Upgrade the difficulty of the targeted character's next check.\";\nconst doSomethingVital =\n  \"Do something vital, such as shooting the controls to the nearby blast doors to seal them shut.\";\nconst upgradeAnyAllyCheck =\n  \"Upgrade any allied character's next check, including that of the current active character.\";\n\n// 2 triumph\nconst destroyEquipment =\n  \"When dealing damage to a target, have the attack destroy a piece of equipment the target is using, such as blowing up his blaster or destroying a personal shield generator.\";\n\n// 1 threat or 1 despair\nconst sufferStrain = \"The active character suffers 1 strain.\";\nconst loseManeuverBenefit =\n  \"The active character loses the benefits of a prior maneuver (such as from taking cover or assuming a Guarded Stance) until they perform the maneuver again.\";\n\n// 2 threat or 1 despair\nconst freeManeuver =\n  \"An opponent may immediately perform one free maneuver in response to the active character's check.\";\nconst addBoostDieToTargetedCharacter =\n  \"Add a boost die to the targeted character's next check.\";\nconst sufferSetback =\n  \"The active character or an allied character suffers a setback die on their next action.\";\n\n// 3 threat or 1 despair\nconst fallProne = \"The active character falls prone.\";\nconst gainSignificantAdvantage =\n  \"The active character grants the enemy a significant advantage in the ongoing encounter, such as accidentally blasting the controls to a bridge the active character was planning to use for their escape.\";\n\n// 1 despair\nconst outOfAmmo =\n  \"The character's ranged weapon imediately runs out of ammunition and may not be used for the remainder of the encounter.\";\nconst upgradeDifficultyAlliedCharacter =\n  \"Upgrade the difficulty of an allied character's next check, including that of the current active character.\";\nconst damagedItem =\n  \"The tool or melee weapon the character is using becomes damaged.\";\n\nexport type CostType = {\n  [key in Symbol]?: number;\n};\n\ntype Hint = {\n  description: string;\n  cost: CostType;\n};\n\nexport const hints: Hint[] = [\n  // 1 advantage or 1 triumph\n  {\n    description: recoverOneStrain,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: addBoostDieToActiveAlly,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: noticeImportantPoint,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: inflictCriticalInjury,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: activateWeaponQuality,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  // 2 advantage or 1 triumph\n  {\n    description: performManeuver,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 2,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: addSetbackDie,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 2,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: addBoostDieToAnyAlly,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 2,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  // 3 advantage or 1 triumph\n  {\n    description: negateEnemy,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: ignoreEnvironment,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: disableOpponent,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: gainDefense,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: dropWeapon,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  // 1 triumph\n  {\n    description: upgradeDifficultyTargetedCharacter,\n    cost: {\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: doSomethingVital,\n    cost: {\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: upgradeAnyAllyCheck,\n    cost: {\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  // 2 triumph\n  {\n    description: destroyEquipment,\n    cost: {\n      [SYMBOLS.TRIUMPH]: 2,\n    },\n  },\n  // 1 threat or 1 despair\n  {\n    description: sufferStrain,\n    cost: {\n      [SYMBOLS.THREAT]: 1,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: loseManeuverBenefit,\n    cost: {\n      [SYMBOLS.THREAT]: 1,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  // 2 threat or 1 despair\n  {\n    description: freeManeuver,\n    cost: {\n      [SYMBOLS.THREAT]: 2,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: addBoostDieToTargetedCharacter,\n    cost: {\n      [SYMBOLS.THREAT]: 1,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: sufferSetback,\n    cost: {\n      [SYMBOLS.THREAT]: 2,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  // 3 threat or 1 despair\n  {\n    description: fallProne,\n    cost: {\n      [SYMBOLS.THREAT]: 3,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: gainSignificantAdvantage,\n    cost: {\n      [SYMBOLS.THREAT]: 3,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  // 1 despair\n  {\n    description: outOfAmmo,\n    cost: {\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: upgradeDifficultyAlliedCharacter,\n    cost: {\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: damagedItem,\n    cost: {\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n];\n\nexport function hintCostDisplayText(hint: Hint): string {\n  if (!hint.cost || Object.keys(hint.cost).length === 0) {\n    return \"No cost\";\n  }\n  const parts = Object.entries(hint.cost)\n    .filter(([_, count]) => count && count > 0)\n    .map(([symbol, count]) => {\n      const symbolName =\n        symbol.charAt(0).toUpperCase() + symbol.toLowerCase().slice(1);\n      const plural = count > 1 ? \"s\" : \"\";\n      return `${count} ${symbolName}${plural}`;\n    });\n\n  // Use \"OR\" in uppercase for clarity when multiple options exist\n  if (parts.length > 1) {\n    return parts.join(\" OR \");\n  }\n  return parts.length > 0 ? parts[0] : \"No cost\";\n}\n", "import { hintCostDisplayText, hints } from \"./hints\";\nimport {\n  DicePool,\n  RollResult,\n  DiceResult,\n  DetailedDieResult,\n  RollOptions,\n} from \"./types\";\n\n// Default dice limits for performance and security\nexport const DEFAULT_MAX_DICE_PER_TYPE = 100;\nexport const DEFAULT_MAX_TOTAL_DICE = 500;\n\nconst rollDie = (sides: number): number =>\n  Math.floor(Math.random() * sides) + 1;\n\nconst boostDieResult = (roll: number): DiceResult => {\n  switch (roll) {\n    case 3:\n      return {\n        successes: 1,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 4:\n      return {\n        successes: 1,\n        failures: 0,\n        advantages: 1,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 5:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 2,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 6:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 1,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    default:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n  }\n};\n\nconst setBackDieResult = (roll: number): DiceResult => {\n  switch (roll) {\n    case 3:\n    case 4:\n      return {\n        successes: 0,\n        failures: 1,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 5:\n    case 6:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 1,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    default:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n  }\n};\n\nconst abilityDieResult = (roll: number): DiceResult => {\n  switch (roll) {\n    case 2:\n    case 3:\n      return {\n        successes: 1,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 4:\n      return {\n        successes: 2,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 5:\n    case 6:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 1,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 7:\n      return {\n        successes: 1,\n        failures: 0,\n        advantages: 1,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 8:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 2,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    default:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n  }\n};\n\nconst difficultyDieResult = (roll: number): DiceResult => {\n  switch (roll) {\n    case 2:\n      return {\n        successes: 0,\n        failures: 1,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 3:\n      return {\n        successes: 0,\n        failures: 2,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 4:\n    case 5:\n    case 6:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 1,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 7:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 2,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 8:\n      return {\n        successes: 0,\n        failures: 1,\n        advantages: 0,\n        threats: 1,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    default:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n  }\n};\n\nconst proficiencyDieResult = (roll: number): DiceResult => {\n  switch (roll) {\n    case 2:\n    case 3:\n      return {\n        successes: 1,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 4:\n    case 5:\n      return {\n        successes: 2,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 6:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 1,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 7:\n    case 8:\n    case 9:\n      return {\n        successes: 1,\n        failures: 0,\n        advantages: 1,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 10:\n    case 11:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 2,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 12:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 1,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    default:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n  }\n};\n\nconst challengeDieResult = (roll: number): DiceResult => {\n  switch (roll) {\n    case 2:\n    case 3:\n      return {\n        successes: 0,\n        failures: 1,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 4:\n    case 5:\n      return {\n        successes: 0,\n        failures: 2,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 6:\n    case 7:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 1,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 8:\n    case 9:\n      return {\n        successes: 0,\n        failures: 1,\n        advantages: 0,\n        threats: 1,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 10:\n    case 11:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 2,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    case 12:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 1,\n        lightSide: 0,\n        darkSide: 0,\n      };\n    default:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n  }\n};\n\nconst forceDieResult = (roll: number): DiceResult => {\n  switch (roll) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 1,\n        darkSide: 0,\n      };\n    case 6:\n    case 7:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 2,\n        darkSide: 0,\n      };\n    case 8:\n    case 9:\n    case 10:\n    case 11:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 1,\n      };\n    case 12:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 2,\n      };\n    default:\n      return {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despair: 0,\n        lightSide: 0,\n        darkSide: 0,\n      };\n  }\n};\n\nconst sumResults = (\n  results: DiceResult[],\n  options?: RollOptions,\n): DiceResult => {\n  const sums = results.reduce(\n    (acc, curr) => ({\n      successes: acc.successes + curr.successes,\n      failures: acc.failures + curr.failures,\n      advantages: acc.advantages + curr.advantages,\n      threats: acc.threats + curr.threats,\n      triumphs: acc.triumphs + curr.triumphs,\n      despair: acc.despair + curr.despair,\n      lightSide: acc.lightSide + (curr.lightSide || 0),\n      darkSide: acc.darkSide + (curr.darkSide || 0),\n    }),\n    {\n      successes: 0,\n      failures: 0,\n      advantages: 0,\n      threats: 0,\n      triumphs: 0,\n      despair: 0,\n      lightSide: 0,\n      darkSide: 0,\n    },\n  );\n\n  let netSuccesses = 0;\n  let netFailures = 0;\n\n  if (sums.successes === sums.failures) {\n    netSuccesses = 0;\n    netFailures = 0;\n  } else if (sums.successes > sums.failures) {\n    netSuccesses = sums.successes - sums.failures;\n  } else {\n    netFailures = sums.failures - sums.successes;\n  }\n\n  const result: DiceResult = {\n    successes: netSuccesses,\n    failures: netFailures,\n    advantages: sums.advantages,\n    threats: sums.threats,\n    triumphs: sums.triumphs,\n    despair: sums.despair,\n    lightSide: sums.lightSide,\n    darkSide: sums.darkSide,\n  };\n\n  return result;\n};\n\n/**\n * Rolls a dice pool and returns the results.\n *\n * @param pool - The dice pool to roll\n * @param options - Optional roll configuration including dice limits\n * @returns The roll results with detailed die information and summary\n * @throws {Error} If dice counts exceed configured limits\n *\n * Default limits:\n * - Max dice per type: 100 (configurable via options.maxDicePerType)\n * - Max total dice: 500 (configurable via options.maxTotalDice)\n */\nexport const roll = (pool: DicePool, options?: RollOptions): RollResult => {\n  const boostCount = pool.boostDice ?? 0;\n  const abilityCount = pool.abilityDice ?? 0;\n  const proficiencyCount = pool.proficiencyDice ?? 0;\n  const setBackCount = pool.setBackDice ?? 0;\n  const difficultyCount = pool.difficultyDice ?? 0;\n  const challengeCount = pool.challengeDice ?? 0;\n  const forceCount = pool.forceDice ?? 0;\n\n  // Get limits from options or use defaults\n  const maxDicePerType = options?.maxDicePerType ?? DEFAULT_MAX_DICE_PER_TYPE;\n  const maxTotalDice = options?.maxTotalDice ?? DEFAULT_MAX_TOTAL_DICE;\n\n  // Ensure all dice counts are non-negative and apply per-type limits\n  const sanitizedPool = {\n    boostDice: Math.max(0, Math.min(boostCount, maxDicePerType)),\n    abilityDice: Math.max(0, Math.min(abilityCount, maxDicePerType)),\n    proficiencyDice: Math.max(0, Math.min(proficiencyCount, maxDicePerType)),\n    setBackDice: Math.max(0, Math.min(setBackCount, maxDicePerType)),\n    difficultyDice: Math.max(0, Math.min(difficultyCount, maxDicePerType)),\n    challengeDice: Math.max(0, Math.min(challengeCount, maxDicePerType)),\n    forceDice: Math.max(0, Math.min(forceCount, maxDicePerType)),\n  };\n\n  // Check if any dice counts exceeded the per-type limit\n  const exceedsPerTypeLimit =\n    boostCount > maxDicePerType ||\n    abilityCount > maxDicePerType ||\n    proficiencyCount > maxDicePerType ||\n    setBackCount > maxDicePerType ||\n    difficultyCount > maxDicePerType ||\n    challengeCount > maxDicePerType ||\n    forceCount > maxDicePerType;\n\n  // Calculate total dice count\n  const totalDice =\n    sanitizedPool.boostDice +\n    sanitizedPool.abilityDice +\n    sanitizedPool.proficiencyDice +\n    sanitizedPool.setBackDice +\n    sanitizedPool.difficultyDice +\n    sanitizedPool.challengeDice +\n    sanitizedPool.forceDice;\n\n  // Check total dice limit\n  if (totalDice > maxTotalDice) {\n    throw new Error(\n      `Total dice count (${totalDice}) exceeds maximum allowed (${maxTotalDice}). ` +\n        `Please reduce the number of dice in your pool.`,\n    );\n  }\n\n  // Warn if per-type limits were exceeded (but continue with capped values)\n  if (exceedsPerTypeLimit && options?.throwOnLimitExceeded) {\n    const exceeded = [];\n    if (boostCount > maxDicePerType) exceeded.push(`boost: ${boostCount}`);\n    if (abilityCount > maxDicePerType)\n      exceeded.push(`ability: ${abilityCount}`);\n    if (proficiencyCount > maxDicePerType)\n      exceeded.push(`proficiency: ${proficiencyCount}`);\n    if (setBackCount > maxDicePerType)\n      exceeded.push(`setback: ${setBackCount}`);\n    if (difficultyCount > maxDicePerType)\n      exceeded.push(`difficulty: ${difficultyCount}`);\n    if (challengeCount > maxDicePerType)\n      exceeded.push(`challenge: ${challengeCount}`);\n    if (forceCount > maxDicePerType) exceeded.push(`force: ${forceCount}`);\n\n    throw new Error(\n      `Dice counts exceed per-type limit (${maxDicePerType}): ${exceeded.join(\", \")}. ` +\n        `Dice counts have been capped to the maximum.`,\n    );\n  }\n\n  const detailedResults: DetailedDieResult[] = [];\n\n  // Roll boost dice\n  for (let i = 0; i < sanitizedPool.boostDice; i++) {\n    const roll = rollDie(6);\n    detailedResults.push({\n      type: \"boost\",\n      roll,\n      result: boostDieResult(roll),\n    });\n  }\n\n  // Roll ability dice\n  for (let i = 0; i < sanitizedPool.abilityDice; i++) {\n    const roll = rollDie(8);\n    detailedResults.push({\n      type: \"ability\",\n      roll,\n      result: abilityDieResult(roll),\n    });\n  }\n\n  // Roll proficiency dice\n  for (let i = 0; i < sanitizedPool.proficiencyDice; i++) {\n    const roll = rollDie(12);\n    detailedResults.push({\n      type: \"proficiency\",\n      roll,\n      result: proficiencyDieResult(roll),\n    });\n  }\n\n  // Roll setback dice\n  for (let i = 0; i < sanitizedPool.setBackDice; i++) {\n    const roll = rollDie(6);\n    detailedResults.push({\n      type: \"setback\",\n      roll,\n      result: setBackDieResult(roll),\n    });\n  }\n\n  // Roll difficulty dice\n  for (let i = 0; i < sanitizedPool.difficultyDice; i++) {\n    const roll = rollDie(8);\n    detailedResults.push({\n      type: \"difficulty\",\n      roll,\n      result: difficultyDieResult(roll),\n    });\n  }\n\n  // Roll challenge dice\n  for (let i = 0; i < sanitizedPool.challengeDice; i++) {\n    const roll = rollDie(12);\n    detailedResults.push({\n      type: \"challenge\",\n      roll,\n      result: challengeDieResult(roll),\n    });\n  }\n\n  // Roll force dice\n  for (let i = 0; i < sanitizedPool.forceDice; i++) {\n    const roll = rollDie(12);\n    detailedResults.push({\n      type: \"force\",\n      roll,\n      result: forceDieResult(roll),\n    });\n  }\n\n  const summary = sumResults(detailedResults.map((r) => r.result));\n\n  if (options?.hints) {\n    const applicableHints = hints.filter((hint) => {\n      const { cost } = hint;\n      // For OR conditions: at least one option must be fully satisfied\n      // Each entry in cost represents an alternative way to pay for the hint\n      return Object.entries(cost).some(([symbol, required]) => {\n        const summaryKey = (symbol.toLowerCase() + \"s\") as keyof typeof summary;\n        const value = summary[summaryKey];\n        if (typeof value !== \"number\") return false;\n        // Check if we have enough of this symbol type to afford the hint\n        return required !== undefined && required > 0 && value >= required;\n      });\n    });\n    summary.hints = applicableHints.map(\n      (hint) => `${hintCostDisplayText(hint)} - ${hint.description}`,\n    );\n  }\n\n  return {\n    results: detailedResults,\n    summary: summary,\n  };\n};\n", "import { DicePool } from \"./types\";\n\n/**\n * Creates a basic skill check dice pool\n * @param ability Number of ability (green) dice\n * @param proficiency Number of proficiency (yellow) dice\n * @returns DicePool configured for a basic skill check\n */\nexport const createSkillCheck = (\n  ability: number,\n  proficiency: number,\n): DicePool => ({\n  abilityDice: Math.max(0, ability),\n  proficiencyDice: Math.max(0, proficiency),\n});\n\n/**\n * Creates a combat check dice pool with optional boost die\n * @param ability Number of ability (green) dice\n * @param proficiency Number of proficiency (yellow) dice\n * @param boost Number of boost (blue) dice\n * @returns DicePool configured for a combat check\n */\nexport const createCombatCheck = (\n  ability: number,\n  proficiency: number,\n  boost: number = 0,\n): DicePool => ({\n  abilityDice: Math.max(0, ability),\n  proficiencyDice: Math.max(0, proficiency),\n  boostDice: Math.max(0, boost),\n});\n\n/**\n * Creates an opposed check dice pool\n * @param ability Number of ability (green) dice\n * @param proficiency Number of proficiency (yellow) dice\n * @param difficulty Number of difficulty (purple) dice\n * @param challenge Number of challenge (red) dice\n * @returns DicePool configured for an opposed check\n */\nexport const createOpposedCheck = (\n  ability: number,\n  proficiency: number,\n  difficulty: number,\n  challenge: number = 0,\n): DicePool => ({\n  abilityDice: Math.max(0, ability),\n  proficiencyDice: Math.max(0, proficiency),\n  difficultyDice: Math.max(0, difficulty),\n  challengeDice: Math.max(0, challenge),\n});\n\n/**\n * Creates a difficulty check dice pool\n * @param difficulty Number of difficulty (purple) dice\n * @param challenge Number of challenge (red) dice\n * @returns DicePool configured for a pure difficulty check\n */\nexport const createDifficultyPool = (\n  difficulty: number,\n  challenge: number = 0,\n): DicePool => ({\n  difficultyDice: Math.max(0, difficulty),\n  challengeDice: Math.max(0, challenge),\n});\n", "import { DicePool, roll } from \"@swrpg-online/dice\";\nimport { DiceResult } from \"@swrpg-online/dice/dist/types\";\n\nexport { DicePool };\n\nexport class MonteCarloError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"MonteCarloError\";\n  }\n}\n\nexport interface HistogramData {\n  netSuccesses: { [key: number]: number };\n  netAdvantages: { [key: number]: number };\n  triumphs: { [key: number]: number };\n  despairs: { [key: number]: number };\n  lightSide: { [key: number]: number };\n  darkSide: { [key: number]: number };\n}\n\nexport interface DistributionAnalysis {\n  skewness: number;\n  kurtosis: number;\n  outliers: number[];\n  modes: number[];\n  percentiles: {\n    [key: number]: number; // key: percentile (0-100), value: threshold\n  };\n}\n\nexport interface MonteCarloResult {\n  averages: DiceResult;\n  medians: DiceResult;\n  standardDeviations: DiceResult;\n  successProbability: number;\n  criticalSuccessProbability: number;\n  criticalFailureProbability: number;\n  netPositiveProbability: number;\n  histogram: HistogramData;\n  analysis: {\n    netSuccesses: DistributionAnalysis;\n    netAdvantages: DistributionAnalysis;\n    triumphs: DistributionAnalysis;\n    despairs: DistributionAnalysis;\n    lightSide: DistributionAnalysis;\n    darkSide: DistributionAnalysis;\n  };\n}\n\nexport class MonteCarlo {\n  private readonly dicePool: DicePool;\n  private readonly iterations: number;\n  private histogram: HistogramData = {\n    netSuccesses: {},\n    netAdvantages: {},\n    triumphs: {},\n    despairs: {},\n    lightSide: {},\n    darkSide: {},\n  };\n  private static readonly MIN_ITERATIONS = 100;\n  private static readonly MAX_ITERATIONS = 1000000;\n  private statsCache: Map<string, number> = new Map();\n  private runningStats: {\n    successCount: number;\n    criticalSuccessCount: number;\n    criticalFailureCount: number;\n    netPositiveCount: number;\n    sumSuccesses: number;\n    sumAdvantages: number;\n    sumTriumphs: number;\n    sumFailures: number;\n    sumThreats: number;\n    sumDespair: number;\n    sumLightSide: number;\n    sumDarkSide: number;\n    sumSquaredSuccesses: number;\n    sumSquaredAdvantages: number;\n    sumSquaredThreats: number;\n    sumSquaredFailures: number;\n    sumSquaredDespair: number;\n    sumSquaredLightSide: number;\n    sumSquaredDarkSide: number;\n    sumSquaredTriumphs: number;\n  } = {\n    successCount: 0,\n    criticalSuccessCount: 0,\n    criticalFailureCount: 0,\n    netPositiveCount: 0,\n    sumSuccesses: 0,\n    sumAdvantages: 0,\n    sumTriumphs: 0,\n    sumFailures: 0,\n    sumThreats: 0,\n    sumDespair: 0,\n    sumLightSide: 0,\n    sumDarkSide: 0,\n    sumSquaredSuccesses: 0,\n    sumSquaredAdvantages: 0,\n    sumSquaredThreats: 0,\n    sumSquaredFailures: 0,\n    sumSquaredDespair: 0,\n    sumSquaredLightSide: 0,\n    sumSquaredDarkSide: 0,\n    sumSquaredTriumphs: 0,\n  };\n  private results: DiceResult[] = [];\n\n  constructor(\n    dicePool: DicePool,\n    iterations: number = 10000,\n    runSimulate: boolean = true,\n  ) {\n    this.validateDicePool(dicePool);\n    this.validateIterations(iterations);\n    this.dicePool = dicePool;\n    this.iterations = iterations;\n    this.resetRunningStats();\n    if (runSimulate) {\n      this.simulate();\n    }\n  }\n\n  private validateDicePool(dicePool: DicePool): void {\n    if (!dicePool || typeof dicePool !== \"object\") {\n      throw new MonteCarloError(\n        \"Invalid dice pool: must be a valid DicePool object\",\n      );\n    }\n\n    const diceTypes = [\n      \"abilityDice\",\n      \"proficiencyDice\",\n      \"boostDice\",\n      \"setBackDice\",\n      \"difficultyDice\",\n      \"challengeDice\",\n      \"forceDice\",\n    ];\n\n    // Check if at least one die type is present\n    const hasAnyDice = diceTypes.some(\n      (type) =>\n        dicePool[type as keyof DicePool] &&\n        dicePool[type as keyof DicePool]! > 0,\n    );\n\n    if (!hasAnyDice) {\n      throw new MonteCarloError(\n        \"Invalid dice pool: must contain at least one die\",\n      );\n    }\n\n    // Validate each die count is non-negative\n    diceTypes.forEach((type) => {\n      const count = dicePool[type as keyof DicePool];\n      if (count !== undefined && (count < 0 || !Number.isInteger(count))) {\n        throw new MonteCarloError(\n          `Invalid ${type}: must be a non-negative integer`,\n        );\n      }\n    });\n  }\n\n  private validateIterations(iterations: number): void {\n    if (!Number.isInteger(iterations)) {\n      throw new MonteCarloError(\"Iterations must be an integer\");\n    }\n    if (iterations < MonteCarlo.MIN_ITERATIONS) {\n      throw new MonteCarloError(\n        `Iterations must be at least ${MonteCarlo.MIN_ITERATIONS}`,\n      );\n    }\n    if (iterations > MonteCarlo.MAX_ITERATIONS) {\n      throw new MonteCarloError(\n        `Iterations must not exceed ${MonteCarlo.MAX_ITERATIONS}`,\n      );\n    }\n  }\n\n  private calculateHistogramStats(\n    histogram: { [key: number]: number },\n    totalCount: number,\n  ): {\n    mean: number;\n    stdDev: number;\n    sum: number;\n    sumSquares: number;\n  } {\n    let sum = 0;\n    let sumSquares = 0;\n    let count = 0;\n\n    // Single pass to calculate sum and sum of squares\n    for (const [value, freq] of Object.entries(histogram)) {\n      const val = parseInt(value);\n      sum += val * freq;\n      sumSquares += val * val * freq;\n      count += freq;\n    }\n\n    const mean = sum / count;\n    const variance = sumSquares / count - mean * mean;\n    const stdDev = Math.sqrt(Math.max(0, variance)); // Avoid negative values due to floating point errors\n\n    return { mean, stdDev, sum, sumSquares };\n  }\n\n  private calculateSkewness(\n    histogram: { [key: number]: number },\n    stats: { mean: number; stdDev: number },\n  ): number {\n    if (stats.stdDev === 0) return 0;\n\n    let sumCubedDeviations = 0;\n    let totalCount = 0;\n\n    for (const [value, freq] of Object.entries(histogram)) {\n      const deviation = (parseInt(value) - stats.mean) / stats.stdDev;\n      sumCubedDeviations += Math.pow(deviation, 3) * freq;\n      totalCount += freq;\n    }\n\n    return sumCubedDeviations / totalCount;\n  }\n\n  private calculateKurtosis(\n    histogram: { [key: number]: number },\n    stats: { mean: number; stdDev: number },\n  ): number {\n    if (stats.stdDev === 0) return 0;\n\n    let sumFourthPowerDeviations = 0;\n    let totalCount = 0;\n\n    for (const [value, freq] of Object.entries(histogram)) {\n      const deviation = (parseInt(value) - stats.mean) / stats.stdDev;\n      sumFourthPowerDeviations += Math.pow(deviation, 4) * freq;\n      totalCount += freq;\n    }\n\n    return sumFourthPowerDeviations / totalCount - 3;\n  }\n\n  private findOutliers(\n    histogram: { [key: number]: number },\n    stats: { mean: number; stdDev: number },\n  ): number[] {\n    if (stats.stdDev === 0) return [];\n    const threshold = 2;\n    return Object.entries(histogram)\n      .filter(\n        ([value]) =>\n          Math.abs(parseInt(value) - stats.mean) > threshold * stats.stdDev,\n      )\n      .map(([value]) => parseInt(value));\n  }\n\n  private analyzeDistribution(\n    histogram: { [key: number]: number },\n    totalCount: number,\n  ): DistributionAnalysis {\n    // Calculate basic statistics in a single pass\n    const stats = this.calculateHistogramStats(histogram, totalCount);\n\n    return {\n      skewness: this.calculateSkewness(histogram, stats),\n      kurtosis: this.calculateKurtosis(histogram, stats),\n      outliers: this.findOutliers(histogram, stats),\n      modes: this.findModes(histogram),\n      percentiles: this.calculatePercentiles(histogram, totalCount),\n    };\n  }\n\n  private average(\n    selector: ((roll: DiceResult) => number) | { name: string },\n  ): number {\n    const selectorName =\n      typeof selector === \"function\"\n        ? selector.name || \"custom\"\n        : selector.name;\n    const cacheKey = `avg_${selectorName}`;\n    if (this.statsCache.has(cacheKey)) {\n      return this.statsCache.get(cacheKey)!;\n    }\n\n    let sum = 0;\n    if (typeof selector === \"function\") {\n      // For function selectors, calculate sum directly\n      sum = this.results.reduce((acc: number, roll: DiceResult) => {\n        const value = selector(roll);\n        if (typeof value !== \"number\" || isNaN(value)) {\n          throw new MonteCarloError(`Invalid selector result: ${value}`);\n        }\n        return acc + value;\n      }, 0);\n    } else {\n      // For named selectors, use running stats\n      switch (selector.name) {\n        case \"successes\":\n          sum = this.runningStats.sumSuccesses;\n          break;\n        case \"advantages\":\n          sum = this.runningStats.sumAdvantages;\n          break;\n        case \"triumphs\":\n          sum = this.runningStats.sumTriumphs;\n          break;\n        case \"failures\":\n          sum = this.runningStats.sumFailures;\n          break;\n        case \"threats\":\n          sum = this.runningStats.sumThreats;\n          break;\n        case \"despair\":\n          sum = this.runningStats.sumDespair;\n          break;\n        case \"lightSide\":\n          sum = this.runningStats.sumLightSide;\n          break;\n        case \"darkSide\":\n          sum = this.runningStats.sumDarkSide;\n          break;\n        default:\n          throw new MonteCarloError(`Unknown selector: ${selector.name}`);\n      }\n    }\n\n    const avg = sum / this.iterations;\n    this.statsCache.set(cacheKey, avg);\n    return avg;\n  }\n\n  private standardDeviation(\n    selector: ((roll: DiceResult) => number) | { name: string },\n  ): number {\n    const selectorName =\n      typeof selector === \"function\"\n        ? selector.name || \"custom\"\n        : selector.name;\n    const cacheKey = `std_${selectorName}`;\n    if (this.statsCache.has(cacheKey)) {\n      return this.statsCache.get(cacheKey)!;\n    }\n\n    const avg = this.average(selector);\n    let squareSum = 0;\n\n    if (typeof selector === \"function\") {\n      // For function selectors, calculate square sum directly\n      squareSum = this.results.reduce((acc: number, roll: DiceResult) => {\n        const value = selector(roll);\n        if (typeof value !== \"number\" || isNaN(value)) {\n          throw new MonteCarloError(`Invalid selector result: ${value}`);\n        }\n        return acc + value * value;\n      }, 0);\n    } else {\n      // For named selectors, use running stats\n      switch (selector.name) {\n        case \"successes\":\n          squareSum = this.runningStats.sumSquaredSuccesses;\n          break;\n        case \"advantages\":\n          squareSum = this.runningStats.sumSquaredAdvantages;\n          break;\n        case \"threats\":\n          squareSum = this.runningStats.sumSquaredThreats;\n          break;\n        case \"triumphs\":\n          squareSum = this.runningStats.sumSquaredTriumphs;\n          break;\n        case \"failures\":\n          squareSum = this.runningStats.sumSquaredFailures;\n          break;\n        case \"despair\":\n          squareSum = this.runningStats.sumSquaredDespair;\n          break;\n        case \"lightSide\":\n          squareSum = this.runningStats.sumSquaredLightSide;\n          break;\n        case \"darkSide\":\n          squareSum = this.runningStats.sumSquaredDarkSide;\n          break;\n        default:\n          throw new MonteCarloError(`Unknown selector: ${selector.name}`);\n      }\n    }\n\n    const stdDev = Math.sqrt(Math.abs(squareSum / this.iterations - avg * avg));\n    this.statsCache.set(cacheKey, stdDev);\n    return stdDev;\n  }\n\n  private resetRunningStats(): void {\n    this.runningStats = {\n      successCount: 0,\n      criticalSuccessCount: 0,\n      criticalFailureCount: 0,\n      netPositiveCount: 0,\n      sumSuccesses: 0,\n      sumAdvantages: 0,\n      sumTriumphs: 0,\n      sumFailures: 0,\n      sumThreats: 0,\n      sumDespair: 0,\n      sumLightSide: 0,\n      sumDarkSide: 0,\n      sumSquaredSuccesses: 0,\n      sumSquaredAdvantages: 0,\n      sumSquaredThreats: 0,\n      sumSquaredFailures: 0,\n      sumSquaredDespair: 0,\n      sumSquaredLightSide: 0,\n      sumSquaredDarkSide: 0,\n      sumSquaredTriumphs: 0,\n    };\n  }\n\n  private updateHistogram(result: DiceResult): void {\n    // Update net successes with direct array access\n    const netSuccesses = result.successes - result.failures;\n    this.histogram.netSuccesses[netSuccesses] =\n      (this.histogram.netSuccesses[netSuccesses] || 0) + 1;\n\n    // Update net advantages with direct array access\n    const netAdvantages = result.advantages - result.threats;\n    this.histogram.netAdvantages[netAdvantages] =\n      (this.histogram.netAdvantages[netAdvantages] || 0) + 1;\n\n    // Update other histograms with direct array access\n    this.histogram.triumphs[result.triumphs] =\n      (this.histogram.triumphs[result.triumphs] || 0) + 1;\n    this.histogram.despairs[result.despair] =\n      (this.histogram.despairs[result.despair] || 0) + 1;\n    this.histogram.lightSide[result.lightSide] =\n      (this.histogram.lightSide[result.lightSide] || 0) + 1;\n    this.histogram.darkSide[result.darkSide] =\n      (this.histogram.darkSide[result.darkSide] || 0) + 1;\n\n    // Update running statistics\n    this.runningStats.sumSuccesses += result.successes;\n    this.runningStats.sumAdvantages += result.advantages;\n    this.runningStats.sumTriumphs += result.triumphs;\n    this.runningStats.sumFailures += result.failures;\n    this.runningStats.sumThreats += result.threats;\n    this.runningStats.sumDespair += result.despair;\n    this.runningStats.sumLightSide += result.lightSide;\n    this.runningStats.sumDarkSide += result.darkSide;\n    this.runningStats.sumSquaredSuccesses +=\n      result.successes * result.successes;\n    this.runningStats.sumSquaredAdvantages +=\n      result.advantages * result.advantages;\n    this.runningStats.sumSquaredThreats += result.threats * result.threats;\n    this.runningStats.sumSquaredFailures += result.failures * result.failures;\n    this.runningStats.sumSquaredDespair += result.despair * result.despair;\n    this.runningStats.sumSquaredLightSide +=\n      result.lightSide * result.lightSide;\n    this.runningStats.sumSquaredDarkSide += result.darkSide * result.darkSide;\n    this.runningStats.sumSquaredTriumphs += result.triumphs * result.triumphs;\n\n    if (netSuccesses > 0) {\n      this.runningStats.successCount++;\n      if (netAdvantages > 0) {\n        this.runningStats.netPositiveCount++;\n      }\n    }\n    if (result.triumphs > 0) this.runningStats.criticalSuccessCount++;\n    if (result.despair > 0) this.runningStats.criticalFailureCount++;\n  }\n\n  public simulate(): MonteCarloResult {\n    try {\n      this.resetHistogram();\n      this.resetRunningStats();\n      this.statsCache.clear();\n      this.results = [];\n\n      // Run simulations and update histograms in a single pass\n      for (let i = 0; i < this.iterations; i++) {\n        const rollResult = roll(this.dicePool);\n        this.results.push(rollResult.summary);\n        this.updateHistogram(rollResult.summary);\n      }\n\n      // Calculate probabilities using running statistics\n      const successProbability =\n        this.runningStats.successCount / this.iterations;\n      const criticalSuccessProbability =\n        this.runningStats.criticalSuccessCount / this.iterations;\n      const criticalFailureProbability =\n        this.runningStats.criticalFailureCount / this.iterations;\n      const netPositiveProbability =\n        this.runningStats.netPositiveCount / this.iterations;\n\n      // Calculate averages using running statistics\n      const averages = {\n        successes: this.runningStats.sumSuccesses / this.iterations,\n        advantages: this.runningStats.sumAdvantages / this.iterations,\n        triumphs: this.runningStats.sumTriumphs / this.iterations,\n        failures: this.runningStats.sumFailures / this.iterations,\n        threats: this.runningStats.sumThreats / this.iterations,\n        despair: this.runningStats.sumDespair / this.iterations,\n        lightSide: this.runningStats.sumLightSide / this.iterations,\n        darkSide: this.runningStats.sumDarkSide / this.iterations,\n      };\n\n      // Calculate standard deviations using running statistics\n      const standardDeviations = {\n        successes: Math.sqrt(\n          this.runningStats.sumSquaredSuccesses / this.iterations -\n            averages.successes * averages.successes,\n        ),\n        advantages: Math.sqrt(\n          this.runningStats.sumSquaredAdvantages / this.iterations -\n            averages.advantages * averages.advantages,\n        ),\n        triumphs: Math.sqrt(\n          this.runningStats.sumSquaredTriumphs / this.iterations -\n            averages.triumphs * averages.triumphs,\n        ),\n        failures: Math.sqrt(\n          this.runningStats.sumSquaredFailures / this.iterations -\n            averages.failures * averages.failures,\n        ),\n        threats: Math.sqrt(\n          this.runningStats.sumSquaredThreats / this.iterations -\n            averages.threats * averages.threats,\n        ),\n        despair: Math.sqrt(\n          this.runningStats.sumSquaredDespair / this.iterations -\n            averages.despair * averages.despair,\n        ),\n        lightSide: Math.sqrt(\n          this.runningStats.sumSquaredLightSide / this.iterations -\n            averages.lightSide * averages.lightSide,\n        ),\n        darkSide: Math.sqrt(\n          this.runningStats.sumSquaredDarkSide / this.iterations -\n            averages.darkSide * averages.darkSide,\n        ),\n      };\n\n      // Calculate medians using histogram data\n      const medians = {\n        successes: this.calculateMedianFromHistogram(\n          this.histogram.netSuccesses,\n        ),\n        advantages: this.calculateMedianFromHistogram(\n          this.histogram.netAdvantages,\n        ),\n        triumphs: this.calculateMedianFromHistogram(this.histogram.triumphs),\n        failures: this.calculateMedianFromHistogram(this.histogram.despairs),\n        threats: this.calculateMedianFromHistogram(\n          this.histogram.netAdvantages,\n        ),\n        despair: this.calculateMedianFromHistogram(this.histogram.despairs),\n        lightSide: this.calculateMedianFromHistogram(this.histogram.lightSide),\n        darkSide: this.calculateMedianFromHistogram(this.histogram.darkSide),\n      };\n\n      // Calculate analysis for each histogram category\n      const analysis = {\n        netSuccesses: this.analyzeDistribution(\n          this.histogram.netSuccesses,\n          this.iterations,\n        ),\n        netAdvantages: this.analyzeDistribution(\n          this.histogram.netAdvantages,\n          this.iterations,\n        ),\n        triumphs: this.analyzeDistribution(\n          this.histogram.triumphs,\n          this.iterations,\n        ),\n        despairs: this.analyzeDistribution(\n          this.histogram.despairs,\n          this.iterations,\n        ),\n        lightSide: this.analyzeDistribution(\n          this.histogram.lightSide,\n          this.iterations,\n        ),\n        darkSide: this.analyzeDistribution(\n          this.histogram.darkSide,\n          this.iterations,\n        ),\n      };\n\n      return {\n        averages,\n        medians,\n        standardDeviations,\n        successProbability,\n        criticalSuccessProbability,\n        criticalFailureProbability,\n        netPositiveProbability,\n        histogram: this.histogram,\n        analysis,\n      };\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new MonteCarloError(`Simulation failed: ${error.message}`);\n      }\n      throw new MonteCarloError(\"Simulation failed with unknown error\");\n    }\n  }\n\n  private resetHistogram(): void {\n    this.histogram = {\n      netSuccesses: {},\n      netAdvantages: {},\n      triumphs: {},\n      despairs: {},\n      lightSide: {},\n      darkSide: {},\n    };\n  }\n\n  private calculateMedianFromHistogram(histogram: {\n    [key: number]: number;\n  }): number {\n    const entries = Object.entries(histogram)\n      .map(([value, count]) => ({ value: parseInt(value), count }))\n      .sort((a, b) => a.value - b.value);\n\n    if (entries.length === 0) {\n      return 0;\n    }\n\n    let runningCount = 0;\n    const targetCount = this.iterations / 2;\n\n    for (const { value, count } of entries) {\n      runningCount += count;\n      if (runningCount >= targetCount) {\n        return value;\n      }\n    }\n\n    return entries[entries.length - 1].value;\n  }\n\n  private findModes(histogram: { [key: number]: number }): number[] {\n    const entries = Object.entries(histogram);\n    if (entries.length === 0) return [];\n\n    const maxCount = Math.max(...entries.map(([, count]) => count));\n    return entries\n      .filter(([, count]) => count === maxCount)\n      .map(([value]) => parseInt(value));\n  }\n\n  private calculatePercentiles(\n    histogram: { [key: number]: number },\n    totalCount: number,\n  ): { [key: number]: number } {\n    const sortedEntries = Object.entries(histogram)\n      .map(([value, count]) => ({ value: parseInt(value), count }))\n      .sort((a, b) => a.value - b.value);\n\n    if (sortedEntries.length === 0) {\n      return {};\n    }\n\n    const percentiles: { [key: number]: number } = {};\n    let runningCount = 0;\n\n    // Calculate percentiles at specific points\n    const targetPercentiles = [25, 50, 75, 90];\n    let currentTargetIndex = 0;\n\n    // Find the value for each percentile\n    for (const { value, count } of sortedEntries) {\n      runningCount += count;\n      const currentPercentile = (runningCount / totalCount) * 100;\n\n      // Check if we've passed any target percentiles\n      while (\n        currentTargetIndex < targetPercentiles.length &&\n        currentPercentile >= targetPercentiles[currentTargetIndex]\n      ) {\n        percentiles[targetPercentiles[currentTargetIndex]] = value;\n        currentTargetIndex++;\n      }\n    }\n\n    // If we haven't reached all target percentiles, use the maximum value\n    const maxValue = sortedEntries[sortedEntries.length - 1].value;\n    while (currentTargetIndex < targetPercentiles.length) {\n      percentiles[targetPercentiles[currentTargetIndex]] = maxValue;\n      currentTargetIndex++;\n    }\n\n    return percentiles;\n  }\n}\n"],
  "mappings": "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",
  "names": ["SYMBOLS", "hints", "description", "cost", "SYMBOLS_ADVANTAGE", "SYMBOLS_TRIUMPH", "SYMBOLS_THREAT", "SYMBOLS_DESPAIR", "rollDie", "sides", "Math", "floor", "random", "boostDieResult", "roll", "successes", "failures", "advantages", "threats", "triumphs", "despair", "lightSide", "darkSide", "setBackDieResult", "abilityDieResult", "difficultyDieResult", "proficiencyDieResult", "challengeDieResult", "forceDieResult", "pool", "options", "boostCount", "_a", "boostDice", "abilityCount", "_b", "abilityDice", "proficiencyCount", "_c", "proficiencyDice", "setBackCount", "_d", "setBackDice", "difficultyCount", "_e", "difficultyDice", "challengeCount", "_f", "challengeDice", "forceCount", "_g", "forceDice", "maxDicePerType", "_h", "maxTotalDice", "_j", "sanitizedPool", "max", "min", "exceedsPerTypeLimit", "totalDice", "Error", "throwOnLimitExceeded", "exceeded", "push", "join", "detailedResults", "i", "type", "result", "summary", "results", "sums", "reduce", "acc", "curr", "netSuccesses", "netFailures", "map", "r", "applicableHints", "filter", "hint", "Object", "entries", "some", "symbol", "required", "summaryKey", "toLowerCase", "value", "keys", "length", "parts", "_", "count", "charAt", "toUpperCase", "slice", "i", "a"]
}
